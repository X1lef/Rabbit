<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="utf-8">
	<title>Documentación de SL</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<h1>Indice de rutinas predefinidas de SL</h1>
    <hr><h3>abs ()</h3>
	<p>Retorna el valor absoluto de un numero.</p>
	<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> abs (n : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>
	<h4>Ejemplo</h4>
	<p>
    Suponga que desea imprimir la distancia en kilómetros que existe entre dos ciudades, localizadas ambas sobre la misma ruta.
	El usuario ingresa la distancia de ambas ciudades con relación a un punto inicial (por ejemplo Asunción) y el programa imprime
	la distancia entre ambas.
    </p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">c1</span>, <span class="var">c2</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nIngrese la distancia de la ciudad A desde Asunción:"</span>)
   leer (<span class="var">c1</span>)
   imprimir (<span class="string">"Ingrese la distancia de la ciudad B desde Asunción:"</span>)
   leer (<span class="var">c2</span>)
   imprimir (<span class="string">"Entre A y B existen "</span>, abs(<span class="var">c1</span>-<span class="var">c2</span>),<span class="string">" kilómetro(s)"</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>beep()</h3>
<p>Emite un pitido a cierta frecuencia y la ejecución se suspende durante el tiempo que se indica en el segundo parámetro (expresado en milisegundos).
Ambos parámetros pueden omitirse, en cuyo caso se utiliza automáticamente los valores (500, 100), es decir, se emite un pitido y el programa se detiene durante una décima de segundo.<br>
Si la salida actual es un archivo, el pitido no se emite, aunque se hace la pausa solicitada.<br>
Nótese que beep() puede ser utilizado para introducir una pausa en la ejecución, sin emitir pitido propiamente. Por ejemplo beep(0, 500) hará una pausa de al menos medio segundo.</p>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
   <span class="var">t0</span>, <span class="var">t1</span> : numerico
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nIniciamos con un pitido."</span>)
   beep()
   imprimir (<span class="string">"\nAhora haremos una pausa de 3 segundos\n"</span>)
   <span class="var">t0</span> = sec()
   beep (<span class="num">0</span>, <span class="num">3000</span>)
   <span class="var">t1</span> = sec()
   beep()
   imprimir (<span class="string">"Pausa finalizada. Duró "</span>, <span class="var">t1</span>-<span class="var">t0</span>, <span class="string">" segundos"</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>alen()</h3>
<p>Retorna la cantidad de elementos que componen un arreglo. La función opera por igual sobre arreglos abiertos y no abiertos.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> alen (nombre_var) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>El ejemplo que sigue imprimirá la cantidad de elementos de que consta A, que depende de qué valor se ingrese para la var n. Además imprimirá:</p>
<p class="alert">La matriz M tiene 3 filas.<br>Todas las filas tienen 4 columnas.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">A</span> : <span class="resr">vector</span> [<span class="num">10</span>] <span class="resr">numerico</span>
   <span class="var">M</span> : <span class="resr">matriz</span> [*, *] <span class="resr">cadena</span>
   <span class="var">n</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nIngrese tamaño del vector A:"</span>)
   leer (<span class="var">n</span>)

   dim (<span class="var">A</span>, <span class="var">n</span>)
   imprimir (<span class="string">"\nLa cantidad de elementos de A es "</span>, alen (<span class="var">A</span>))

   dim (<span class="var">M</span>, <span class="num">3</span>, <span class="num">4</span>)
   imprimir (<span class="string">"\nLa matriz M tiene "</span>, alen (<span class="var">M</span>), <span class="string">" filas."</span>,
             <span class="string">"\nTodas las filas tienen "</span>, alen (<span class="var">M</span> [<span class="num">1</span>]), <span class="string">" columnas."</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>arctan()</h3>
<p>Calcula el arco tangente (o la inversa de la tangente) de un ángulo, expresado en radianes.
Si tan(w) es z, arctan(z) es w.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> arctan (a : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>ascii()</h3>
<p>Retorna el carácter que se encuentra en la tabla ASCII en la posición dada.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> ascii (n : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<h4>Ejemplo</h4>
<p>El programa que sigue imprime todos los dígitos del “0” al “9” y sus posiciones en la tabla ASCII. Para averiguar la posición del “0”, es decir, la posición inicial de la serie, se usa la función ord().</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">pos_0</span> = ord (<span class="string">"0"</span>)
   <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   <span class="resr">desde</span> <span class="var">k</span> = <span class="var">pos_0</span> <span class="resr">hasta</span> <span class="var">pos_0</span> + <span class="num">9</span> {
      imprimir (<span class="string">"\nCarácter "</span>, ascii (<span class="var">k</span>), <span class="string">". Posición "</span>, <span class="var">k</span>)
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>cos()</h3>
<p>Calcula el coseno de un ángulo expresado en radianes.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> cos (a : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>cls()</h3>
<p>Limpia la pantalla.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> cls ()
</pre>
<p class="alert">La pantalla se limpia solo si el dispositivo de salida al momento de ejecutarse cls() es la pantalla. Si la salida está redireccionada vía set_stdout() a un archivo, cls() no tiene ningún efecto.</p>

<br><hr>
<h3>dec()</h3>
<p>Decrementa el valor de la var que se le pasa como parámetro. En su forma básica, es equivalente a hacer c = c - 1, donde c es una var numérica.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> dec (<span class="resr">ref</span> n : <span class="resr">numerico</span>; decr : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>dim()</h3>
<p>Asigna memoria para los elementos de una matriz o vector que haya sido declarado como "abierto", es decir, con asterisco (*) como tamaño.</p>
<p class="alert">
    Use dim() y arreglos "abiertos" cuando la cantidad de elementos que se requiere depende de un valor que el usuario ingresa, o de un valor que se calcula. En cambio, si la cantidad de elementos ya se conoce al momento de preparar el programa, se puede "dimensionar" ya el arreglo con tal tamaño.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> dim (nombre_var, tam_dim1, tam_dim2, ...)
</pre>
<h4>Ejemplo</h4>
<p>
    El siguiente ejemplo asigna n elementos al vector A, donde el valor de n es proveÍdo por el usuario, así como los valores que serán almacenados en cada posición.<br>
    También inicializa la matriz M con 3 filas y 4 columnas. Muestra también cómo se pueden leer los elementos de un arreglo con una sola llamada a leer(); en este caso se tomarán 12 valores.<br>
    Finalmente, la matriz Z es peculiar en cuanto que una de sus dimensiones es “abierta”, pero la segunda ya tiene un tamaño definido (5 en este caso). Nótese que en estos casos dim() solo recibe tamaños para las dimensiones “abiertas”; las demás son automáticamente completadas por el compilador de SL.
</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">A</span> : <span class="resr">vector</span> [*] <span class="resr">numerico</span>
   <span class="var">M</span> : <span class="resr">matriz</span> [*, *] <span class="resr">cadena</span>
   <span class="var">Z</span> : <span class="resr">matriz</span> [*, <span class="num">5</span>] <span class="resr">numerico</span>
   <span class="var">n</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nIngrese tamaño del vector A:"</span>)
   leer (<span class="var">n</span>)
   dim (<span class="var">A</span>, <span class="var">n</span>)
   <span class="resr">desde</span> <span class="var">k</span>=<span class="num">1</span> <span class="resr">hasta</span> <span class="var">n</span> {
      leer (<span class="var">A</span>[<span class="var">k</span>])
   }

   dim (<span class="var">M</span>, <span class="num">3</span>, <span class="num">4</span>)
   leer (<span class="var">M</span>)

   dim (<span class="var">Z</span>, <span class="var">n</span> * <span class="num">2</span>)
   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen(<span class="var">Z</span>) {
      <span class="comment">/*
       * Por cada iteración, se leerán 5 valores a la vez, ya que
       * cada Z [k] contiene tal cantidad de elementos.
       */</span>
      leer (<span class="var">Z</span> [<span class="var">k</span>])
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>eof()</h3>
<p>Retorna verdadero cuando ya no existen datos que puedan ser leídos desde un archivo.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> eof() <span class="resr">retorna logico</span>
</pre>
<h4>Ejemplo</h4>
<p>El siguiente código imprime cada línea de un archivo llamado datos.txt, mostrando el número de línea correspondiente.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">linea</span> = <span class="string">""</span>
   <span class="var">num_linea</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   set_stdin (<span class="string">"datos.txt"</span>)
   set_ifs (<span class="string">"\n"</span>)
   leer (<span class="var">linea</span>)
   <span class="resr">mientras</span> (<span class="resr">not</span> eof()) {
      inc (<span class="var">num_linea</span>)
      imprimir (<span class="string">"\n"</span>, <span class="var">num_linea</span>, <span class="string">": "</span>, <span class="var">linea</span>)
      leer (<span class="resr">linea</span>)
   }
   imprimir (<span class="string">"\nFueron leídas "</span>, <span class="var">num_linea</span>, <span class="string">" líneas."</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>exp()</h3>
<p>Retorna e elevado a la n, donde e es la base de los logaritmos naturales o neperianos (2.71828182...).</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> exp (n : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>El siguiente código imprime cada línea de un archivo llamado datos.txt, mostrando el número de línea correspondiente.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">base_log_naturales</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   <span class="var">base_log_naturales</span> = exp (<span class="num">1</span>)
   imprimir (<span class="string">"\nLa base de los logaritmos naturales es "</span>, <span class="var">base_log_naturales</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>get_color()</h3>
<p>
    Obtiene el color del texto y del fondo vigentes. Nótese que ambos parámetros son pasados por referencia, por lo que deben ser proveídos dos nombres de variables.<br>Los colores están identificados por un valor entero.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> get_color (<span class="resr">ref</span> primer_plano, fondo : <span class="resr">numerico</span>)
</pre>
<h4>Ejemplo</h4>
<p>El siguiente código imprime cada línea de un archivo llamado datos.txt, mostrando el número de línea correspondiente.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">prim_plano</span>, <span class="var">fondo</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
    get_color (<span class="var">prim_plano</span>, <span class="var">fondo</span>)
   imprimir (<span class="string">"\nLos colores actuales son: Fondo="</span>, <span class="var">fondo</span>, <span class="string">" Texto="</span>, <span class="var">prim_plano</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>get_curpos()</h3>
<p>Informa la línea y columna donde se encuentra actualmente el cursor. Nótese que los dos parámetros que necesita esta rutina son pasados por referencia, es decir, deben ser nombres de variables numéricas.<br>Ambos parámetros retornarán con cero si la salida actual es un archivo y no la pantalla.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> get_curpos (<span class="resr">ref</span> linea_actual, col_actual : <span class="resr">numerico</span>)
</pre>
<h4>Ejemplo</h4>
<p>El siguiente código imprime cada línea de un archivo llamado datos.txt, mostrando el número de línea correspondiente.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">cursor_linea</span>, <span class="var">cursor_col</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nBuenos días."</span>)
   get_curpos (<span class="var">cursor_linea</span>, <span class="var">cursor_col</span>)
   imprimir (<span class="string">"\nBuenas tardes"</span>)
   set_curpos (<span class="var">cursor_linea</span>, <span class="var">cursor_col</span> + <span class="num">1</span>)
   imprimir (<span class="string">"Esto debe mostrarse al lado del saludo inicial."</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>get_ifs()</h3>
<p>
    Retorna el carácter que está vigente como separador de valores o campos en una operación de lectura vía leer().<br>Esta función puede usarse para cambiar temporalmente el separador de campos, usando set_ifs(), y posteriormente restaurar su valor original.<br>Nota: Esta función rara vez se utiliza.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> get_ifs() <span class="resr">retorna cadena</span>
</pre>

<br><hr>
<h3>get_ofs()</h3>
<p>
    Retorna el carácter que está vigente como separador de valores al imprimir, así como el indicador de que un arreglo no está dimensionado. El primero es un solo carácter y ocupa la primera posición en el valor retornado; el segundo inicia en la posición dos.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> get_ofs() <span class="resr">retorna cadena</span>
</pre>

<br><hr>
<h3>ifval()</h3>
<p>
    Dada una condición y dos expresiones e1 y e2, ifval() retorna el valor de e1 si la condición es verdadera y el valor de e2 si es falsa.<br>
    Si bien ifval() luce como una función cualquiera, es diferente en cuanto que evalúa solo una de las expresiones, es decir, implementa lo que se conoce con el nombre de “expresión condicional”.<br>
    Las expresiones e1 y e2 deben coincidir en tipo y pueden corresponder a cualquier tipo simple (numerico, cadena, logico).<br>
    El uso de ifval() suele ayudar a hacer más compacto el código.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> ifval (condicion : <span class="resr">logico</span>,
           < expresion_si_condicion_es_verdadera >,
           < expresion_si_condicion_es_falsa >) <span class="resr">retorna</span> < valor >
</pre>
<h4>Ejemplo</h4>
<p>
    El siguiente ejemplo implementa una subrutina que retorna el nombre del día ("lun", "mar", ...) dado su número de día (1 a 7). Obsérvese cómo la rutina usa ifval() para protegerse de que se le envíe un valor fuera de rango. Sin esta validación, el programa podría interrumpirse, por estar fuera de rango el índice de un vector.<br>
    Como podrá notarse, esta misma validación puede implementarse con una sentencia condicional “si”, solo que el código con ifval(), en este caso, es corto e igualmente legible.
</p>
<pre class="code">
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nEl número de día 3 es "</span>, nombre_dia (<span class="num">3</span>))
   imprimir (<span class="string">"\nEl número de día 9 es "</span>, nombre_dia (<span class="num">9</span>))
<span class="resr">fin</span>

<span class="resr">sub</span> nombre_dia (num_dia : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
<span class="comment">/*
 * Retorna el nombre del día, dado su número (1=domingo, 2=lunes, ...)
 * Si el número de día está fuera de rango, se retorna el texto
 * "MAL"
 */</span>
<span class="resr">var</span>
   <span class="var">nom_dias</span> : <span class="resr">vector</span> [*] <span class="resr">cadena</span> = {<span class="string">"dom"</span>, <span class="string">"lun"</span>, <span class="string">"mar"</span>, <span class="string">"mie"</span>, <span class="string">"jue"</span>, <span class="string">"vie"</span>, <span class="string">"sab"</span>}
<span class="resr">inicio</span>
   <span class="resr">retorna</span> ifval (num_dia > <span class="num">0</span> <span class="resr">and</span> num_dia < <span class="num">8</span>, <span class="var">nom_dias</span> [num_dia], <span class="string">"MAL"</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>imprimir()</h3>
<p>Muestra valores en la pantalla, o los graba en un archivo.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> imprimir (valor_1, valor_2, ...)
</pre>
<p>
    Los valores se muestran o graban en la posición inmediatamente disponible, sin mediar ningún carácter separador. Los valores estructurados se imprimen con cierto formato que se explica más adelante.<br>
    Para facilitar el formateo de los datos, imprimir() reconoce ciertas secuencias de caracteres como especiales (se las suele llamar "secuencias de escape"):
</p>
<table border="1" cellspacing="0">
	<th>Secuencia</th>
	<th>Significado</th>
	<tr>
		<td align="center">\n</td>
		<td>Salto de línea.<br>Cada vez que se encuentre esta secuencia, por sí misma o incrustada en otra cadena, el cursor se mueve a la siguiente línea, en la primera columna. Por lo tanto, todo lo que se imprima a continuación aparece en una línea aparte.</td>
	</tr>
	<tr>
		<td align="center">\t</td>
		<td>Tabulador.<br>Hace que el cursor salte a la posición de la siguiente tabulación. Cada columna de tabulación ocupa 8 caracteres. Puede usarse para encolumnar datos que componen una tabla.</td>
	</tr>
	<tr>
		<td align="center">\\</td>
		<td>El carácter "\".</td>
	</tr>
	<tr>
		<td align="center">\c</td>
		<td>En este caso "c" simboliza cualquier carácter.Por ejemplo "\"" hará que se imprima una comilla doble.</td>
	</tr>
</table>
<h4>Ejemplo 1</h4>
<p>El programa que sigue imprime la tabla de cuadrados y cubos de los números del 1 al 10.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">n</span>, <span class="var">c2</span>, <span class="var">c3</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nNúmero\tCubo\tCuadrado"</span>)
   <span class="resr">desde</span> <span class="var">n</span> = <span class="num">1</span> <span class="resr">hasta</span> <span class="num">10</span> {
      imprimir (<span class="string">"\n"</span>, <span class="var">n</span>, <span class="string">"\t"</span>, <span class="var">n</span> * <span class="var">n</span> * <span class="var">n</span>, <span class="string">"\t"</span>, <span class="var">n</span> * <span class="var">n</span>)
   }
<span class="resr">fin</span>
</pre>

<table cellspacing="3">
	<th>Número</th>
	<th>Cubo</th>
	<th>Cuadrado</th>
	<tr><td>1</td><td>1</td><td>1</td></tr>
	<tr><td>2</td><td>8</td><td>4</td></tr>
	<tr><td>3</td><td>27</td><td>9</td></tr>
	<tr><td>4</td><td>64</td><td>16</td></tr>
	<tr><td>5</td><td>125</td><td>25</td></tr>
	<tr><td>6</td><td>216</td><td>36</td></tr>
	<tr><td>7</td><td>343</td><td>49</td></tr>
	<tr><td>8</td><td>512</td><td>64</td></tr>
	<tr><td>9</td><td>729</td><td>81</td></tr>
	<tr><td>10</td><td>1000</td><td>100</td></tr>
</table>
<h4>Ejemplo 2</h4>
<p>El siguiente código carga en cada posición k del vector A el cuadrado de k. Muestra el vector con una sola llamada a imprimir().</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">A</span> : <span class="resr">vector</span> [<span class="num">50</span>] <span class="resr">numerico</span>
   <span class="var">k</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen(<span class="var">A</span>) {
      <span class="var">A</span> [<span class="var">k</span>] = <span class="var">k</span> * <span class="var">k</span>
   }
   imprimir (<span class="string">"\nResultado: "</span>, <span class="var">A</span>)
<span class="resr">fin</span>
</pre>
<p>Resultado esperado:</p>
<p class="alert"><b>Resultado: </b>1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1
681,1764,1849,1936,2025,2116,2209,2304,2401,2500</p>
<p class="alert">
    Se puede imprimir también matrices y registros; vectores de registros y cualquier combinación de estos. Los valores siempre se separan unos de otros con una coma, o con el carácter que se haya configurado usando set_ofs().<br>
    Si al imprimir un dato estructurado se encuentra un arreglo no dimensionado, se imprime por defecto "< nodim >". Esto se puede cambiar con set_ofs().
</p>

<br><hr>
<h3>inc()</h3>
<p>
    Incrementa el valor de la var que se le pasa como parámetro. En su forma básica, es equivalente a hacer c=c+1, donde c es una var numérica.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> inc (<span class="resr">ref</span> n : <span class="resr">numerico</span>; incr : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>
<p>
    El segundo parámetro es opcional; si se omite, el compilador de SL asume que es el valor 1. El incremento puede ser positivo o negativo. inc() realiza la operación contraria a dec().<br>
    Retorna el valor de la var luego del incremento; este valor es habitualmente ignorado.
</p>
<p class="alert">
    Usando inc() se puede a veces acortar el programa y hacerlo más legible, especialmente cuando se están manipulando elementos de variables estructuradas, como matrices y registros. Esto surge como consecuencia de que la var a ser modificada se referencia una sola vez. El programa resultante será también ligeramente más rápido.<br>
    Note que es más corto y hay menos posibilidad de error al escribir<br>inc (M [mes, k*2+3])<br>en vez de<br>M [mes, k*2+3] = M [mes, k*2+3] + 1
</p>
<h4>Ejemplo</h4>
<p>Vea el ejemplo que se da en <a href="">ord()</a>.</p>

<br><hr>
<h3>int()</h3>
<p>Retorna la parte entera del valor numérico que se le pasa como parámetro.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> int (n : <span class="resr">numerico</span>) <span class="resr">retorna numérico</span>
</pre>
<h4>Ejemplo</h4>
<p>Este programa lee un valor numérico positivo, con o sin decimales, y lo redondea por exceso a 2 decimales.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">n</span> = <span class="num">0</span>
   <span class="var">r</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   imprimir (<span class="var">"\nIngrese un valor numérico positivo con decimales:"</span>)
   leer (<span class="var">n</span>)
   <span class="comment">/*
    * Sumamos 0.5 para que el redondeo sea por exceso.
    */</span>
   <span class="var">r</span> = int ((<span class="var">n</span> * <span class="num">100</span>) + <span class="num">0.5</span>) / <span class="num">100</span>
   imprimir (<span class="string">"Valor original="</span>, <span class="var">n</span>, <span class="string">" Valor redondeado="</span>, <span class="var">r</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>intercambiar()</h3>
<p>
    Intercambia el contenido de dos variables que se pasan como parámetros. Las variables deben coincidir en tipo y pueden corresponder a valores simples, arreglos, registros o cualquier combinación de estos.<br>
    El nombre tradicional de esta rutina es swap(), que quiere decir precisamente intercambiar en inglés. Por ese motivo, también puede usarse swap() como sinónimo de intercambiar().
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> intercambiar (< variable_1 >, < variable_2 >)
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
   <span class="var">a</span> = <span class="num">100</span>
   <span class="var">b</span> = <span class="num">30</span>
   <span class="var">M</span> = <span class="resr">vector</span> [<span class="num">5</span>] <span class="resr">numerico</span> = {<span class="num">10</span>, <span class="num">14</span>, <span class="num">21</span>, <span class="num">3</span>, <span class="num">1</span>}
   <span class="var">N</span> = <span class="resr">vector</span> [<span class="num">5</span>] <span class="resr">numerico</span> = {<span class="num">1</span>, <span class="num">212</span>, <span class="num">31</span>, <span class="num">4</span>, <span class="num">90</span>}
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nAntes de intercambiar: a="</span>, <span class="var">a</span>, <span class="string">" b="</span>, <span class="var">b</span>)
   intercambiar (<span class="var">a</span>, <span class="var">b</span>)
   imprimir (<span class="string">"\nLuego de intercambiar: a="</span>, <span class="var">a</span>, <span class="string">" b="</span>, <span class="var">b</span>)
   imprimir (<span class="string">"\nAntes de intercambiar: M="</span>, <span class="var">M</span>, <span class="string">" N="</span>, <span class="var">N</span>)
   intercambiar (<span class="var">M</span>, <span class="var">N</span>)
   imprimir (<span class="string">"\nLuego de intercambiar: M="</span>, <span class="var">M</span>, <span class="string">" N="</span>, <span class="var">N</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>log()</h3>
<p>
    Calcula el logaritmo base 10 de un número n mayor a cero.<br>Si el número n es menor o igual a cero, se produce un error de ejecución y el programa terminará.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> log (n : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>lower()</h3>
<p>
    Dada una cadena como parámetro, retorna una nueva cadena que consta de los mismos caracteres del parámetro, pero con aquellos que sean alfabéticos convertidos a minúsculas.<br>
    Vea también <a href="">upper()</a>.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> lower (c : <span class="resr">cadena</span>) <span class="resr">retorna cadena</span>
</pre>

<br><hr>
<h3>max()</h3>
<p>
    Dados dos valores simples, retorna una copia del mayor de ellos. Los valores pueden ser numéricos, cadenas o lógicos y ambos deben coincidir en tipo.<br>
    La cadena vacía "" se considera que es menor a cualquier cadena no vacía.<br>Vea también la función <a href="">min()</a>.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> max (valor_1, valor_2) <span class="resr">retorna</span> < valor_mayor >
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
   <span class="var">nombres</span> : <span class="resr">vector</span> [*] <span class="resr">cadena</span> = {<span class="string">"Pablo"</span>, <span class="string">"Maria"</span>, <span class="string">"Ana"</span>, <span class="string">"Marco"</span>}
   <span class="var">ult</span> = <span class="string">""</span>
   <span class="var">k</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen(<span class="var">nombres</span>) {
      <span class="var">ult</span> = <span class="resr">max</span> (<span class="var">ult</span>, <span class="var">nombres</span> [<span class="var">k</span>])
   }
   imprimir (<span class="string">"\nLa última persona sería "</span>, <span class="var">ult</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>min()</h3>
<p>
    Dados dos valores simples, retorna una copia del menor de ellos. Los valores pueden ser numéricos, cadenas o lógicos y ambos deben coincidir en tipo.<br>
    Vea también la función <a href="">max()</a>.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> min (valor_1, valor_2) <span class="resr">retorna</span> < menor_valor >
</pre>
<h4>Ejemplo</h4>
<p>Dados tres valores numéricos, imprimir el menor de ellos, si es que existe tal menor valor.</p>
<pre class="code">
<span class="resr">var</span>
    <span class="var">a</span>, <span class="var">b</span>, <span class="var">c</span> : <span class="resr">numerico</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nIngrese tres valores numéricos:"</span>)
   leer (<span class="var">a</span>, <span class="var">b</span>, <span class="var">c</span>)
   <span class="resr">si</span> (<span class="var">a</span> == <span class="var">b</span> <span class="resr">and</span> <span class="var">b</span> == <span class="var">c</span>) {
      imprimir (<span class="string">"\nLos tres valores son iguales; no existe un valor menor"</span>)
   <span class="resr">sino</span>
      imprimir (<span class="string">"\nEl menor valor es "</span>, min (min (<span class="var">a</span>, <span class="var">b</span>), <span class="var">c</span>))
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>ord()</h3>
<p>Retorna la posición que ocupa un determinado carácter en la tabla ASCII.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> ord (c : <span class="resr">cadena</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>
    Este programa calcula cuántas veces aparece cada letra mayúscula del alfabeto inglés (A a Z, sin Ñ) en una cadena que el usuario ingresa.<br>
    Se utiliza el vector F para almacenar la frecuencia de aparición de cada carácter. La primera posición corresponde a la letra “A”, la segunda 
    a la “B” y así sucesivamente. Como la letra “A” se encuentra en la posición 65 en la tabla ASCII, la "B" en la posición 66 y así sucesivamente, se utiliza la función ord() para asociar 1 a la "A", 2 a la "B", etc, a través de una sencilla fórmula.
</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">k</span> = <span class="num">0</span>
   <span class="var">z</span> = <span class="string">""</span>
   <span class="var">c</span> = <span class="string">""</span>
   <span class="var">F</span> : <span class="resr">vector</span> [<span class="num">26</span>] <span class="resr">numerico</span>
<span class="resr">inicio</span>
   leer (<span class="var">z</span>)
   <span class="var">F</span> = {<span class="num">0</span>, ...}
   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> strlen (<span class="var">z</span>) {
      <span class="var">c</span> = upper (<span class="var">z</span> [<span class="var">k</span>])
      <span class="comment">/*
       * Como la "A" está en la posición 65 en la tabla ASCII,
       * convertimos 65 en 1, 66 en 2, etc. usando la expresión
       * ord (c) – pos_A + 1
       */</span>
      <span class="resr">si</span> (<span class="var">c</span> >= <span class="string">"A"</span> <span class="resr">and</span> <span class="var">c</span> <= <span class="string">"Z"</span>) {
         inc (<span class="var">F</span> [ord (<span class="var">c</span>) – <span class="var">pos_A</span> + <span class="num">1</span>])
      }
   }

   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen (<span class="var">F</span>) {
      imprimir (<span class="string">"\nEl carácter "</span>, ascii (<span class="var">pos_A</span> + <span class="var">k</span> – <span class="num">1</span>),
                <span class="string">" aparece "</span>, <span class="var">F</span> [<span class="var">k</span>], <span class="string">" veces."</span>)
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>paramval()</h3>
<p>
    Retorna un parámetro posicional que fue pasado al programa SL, ya sea desde la línea de comandos o desde el entorno de programación.<br>
    El valor retornado es siempre una cadena.<br>Vea también <a href="">pcount()</a>.<br><b>Nota:</b> Esta función es rara vez usada.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> paramval (p : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<p>El valor de p debe estar entre 1 y pcount(); si no lo está, se retorna una cadena vacía.</p>
<h4>Ejemplo</h4>
<p>Imprime cada parámetro que se haya pasado al programa SL, uno por línea.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nLista de parámetros pasados al programa:"</span>)
   <span class="resr">desde</span> <span class="var">k</span> = <span class="var">1</span> <span class="resr">hasta</span> pcount() {
      imprimir (<span class="string">"\n"</span>, <span class="var">k</span>, <span class="string">" "</span>, paramval(<span class="var">k</span>))
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>pcount()</h3>
<p>
    Retorna la cantidad de parámetros que fueron pasados al programa SL, ya sea desde la línea de comandos o desde el entorno de programación.<br>
    Vea también paramval().<br><b>Nota:</b> Esta función es rara vez usada.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> pcount() <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>Vea <a href="">paramval()</a>.</p>

<br><hr>
<h3>pos()</h3>
<p>
    Busca una cadena dentro de otra y retorna la posición en que aparece por primera vez una concordancia, si la misma se da.<br>
    El primer parámetro de la función es la cadena que posiblemente contiene la secuencia de caracteres que se desea buscar.<br>
    El segundo parámetro es lo que se desea buscar.<br>
    Opcionalmente puede especificarse una posición inicial para la búsqueda; si esto se omite, el compilador de SL genera código para buscar desde el primer carácter del primer parámetro.
</p>
<h4>Sintaxis</h4>
<p>
    <u>Alternativa 1</u> : Buscando desde el principio.
</p>
<pre class="code">
<span class="resr">sub</span> pos (donde_buscar : <span class="resr">cadena</span>; valor_buscado : <span class="resr">cadena</span>) <span class="resr">retorna numerico</span>
</pre>
<p>
    <u>Alternativa 2</u> : Buscando desde cierta posición en adelante.
</p>
<pre class="code">
<span class="resr">sub</span> pos (donde_buscar : <span class="resr">cadena</span>; valor_buscado : <span class="resr">cadena</span>; posc_inicial : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>Imprime cada parámetro que se haya pasado al programa SL, uno por línea.</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">prosa</span> = <span class="string">"Cuando haya acabado esta guerra, y acabará pronto, ..."</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\n"</span>, pos(<span class="var">prosa</span>, <span class="string">"acaba"</span>))
   imprimir (<span class="string">"\n"</span>, pos(<span class="var">prosa</span>, <span class="string">"paz"</span>))
   <span class="comment">/*
    * Debe encontrar la segunda aparición de la "acaba", pues la primera
    * inicia en la posición 13.
    */</span>
   imprimir (<span class="string">"\n"</span>, pos(<span class="var">prosa</span>, <span class="string">"acaba"</span>, <span class="num">14</span>))
<span class="resr">fin</span>
</pre>
<p>El programa anterior imprimira</p>
<p class="alert">
    13<br>
    0<br>
    36
</p>

<br><hr>
<h3>random()</h3>
<p>
    Genera un número pseudo-aleatorio cada vez que se la invoca. El resultado es un entero mayor o igual a cero y menor a un valor tope que se pasa como parámetro.
    Opcionalmente puede proveerse un segundo parámetro como “semilla” o valor inicial que se inyecta al generador de números pseudo-aleatorios. Si pasa este parámetro, asegúrese de hacerlo una sola vez en todo su programa.<br>
    <b>Nota:</b> Se recomienda omitir esta “semilla”, ya que SL la inicializa automáticamente al iniciar la ejecución del programa.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> random (tope : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo 1</h4>
<p>
    El siguiente programa imprime 10 números elegidos “al azar”. Todos serán menores a 200. El cero podría aparecer.<br>
    Observe que cada vez que se lo ejecute, se obtendrán potencialmente diferentes valores.
</p>
<pre class="code">
<span class="resr">var</span>
   <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
    <span class="resr">desde</span><span class="var"> k</span> = <span class="num">1</span> <span class="resr">hasta</span> <span class="num">10</span> {
        imprimir (random(<span class="num">200</span>), <span class="string">""</span>)
    }
<span class="resr">fin</span>
</pre>
 <h4>Ejemplo 2</h4>
<p>
    Suponga que desea simular el proceso de tirar 50 veces una moneda y obtener cuántas caras y cuántas cruces cayeron. El siguiente programa hace esta simulación usando random().<br>
    Como random() utiliza una distribución uniforme, si se ejecutara este programa varias veces y se calculara un promedio de los resultados, se encontraría que las caras y cruces se distribuyen en una proporción igual o cercana a 50% cada una, como es de esperarse en un experimento de la vida real.
</p>
<pre class="code">
<span class="resr">var</span>
    <span class="var">cant_cara</span> = <span class="num">0</span>
    <span class="var">cant_cruz</span> = <span class="num">0</span>
    <span class="var">tirada</span> = <span class="num">0</span>
    <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
    <span class="resr">desde</span><span class="var"> k</span> = <span class="num">1</span> <span class="resr">hasta</span> <span class="num">50</span> {
        <span class="comment">/*
        * En este caso, random() producirá solo dos valores posibles: ceros y
        * unos. Asumamos que cero es cara y uno es cruz.
        */</span>
        <span class="var">tirada</span> = random (<span class="num">2</span>)
        <span class="resr">si</span> (<span class="var">tirada</span> == <span class="num">0</span>) {
            inc (<span class="var">cant_cara</span>)
        <span class="resr">sino</span>
            inc (<span class="var">cant_cruz</span>)
        }
        imprimir (<span class="string">"\nCantidad de caras: "</span>, <span class="var">cant_cara</span>,<span class="string"> "\nCantidad de cruces:"</span>, <span class="var">cant_cruz</span>)
    }
<span class="resr">fin</span>
</pre>  

<br><hr>
<h3>readkey()</h3>
<p>
    Espera a que se pulse una tecla y retorna un código numérico que identifica lo pulsado por el usuario. El tiempo que se espera depende del parámetro, que está expresado en milisegundos.<br>
    Si se omite el parámetro, readkey() espera indefinidamente a que el usuario pulse una tecla. De contrario esperará el tiempo que se le indique (en milisegundos) , y si nada se pulsó en ese tiempo, retornará cero.<br>
    Por una decisión de diseño y portabilidad de SL, no se asigna ningún significado específico al valor retornado por esta función, aunque el usuario es libre de experimentar y observar qué valores se generan para cada tecla.<br>
    Si el dispositivo de entrada no es el teclado, porque por ejemplo es un archivo, retorna cero.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> readkey (milisegundos : <span class="resr">numerico</span>)<span class="resr"> retorna numerico</span>
</pre>

<br><hr>
<h3>runcmd()</h3>
<p>
    Ejecuta un programa externo cualquiera y retorna el estado de salida del proceso. El parámetro pasado a runcmd() incluye el nombre del comando y los argumentos que éste necesite. La ejecución del comando se realiza vía el procesador de comandos del usuario y las reglas de localización del comando externo son las de aquel.<br>
    El valor de retorno de runcmd() es el valor de salida, también llamado "estado de salida", del comando ejecutado.<br>
    Si la ejecución del comando no puede realizarse, runcmd() retorna 127. Nótese que este valor es arbitrario y bien podría ser que un comando se ejecute correctamente y retorne 127.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> rumcmd (cmd : <span class="resr">cadena</span>)<span class="resr"> retorna numerico</span>
</pre>

<br><hr>
<h3>sec()</h3>
<p>
    Retorna el tiempo transcurrido (en segundos) desde la medianoche del 1 de enero de 1970.<br>
    Esta función puede servir para medir el tiempo transcurrido de un momento a otro.<br>
    <b>Nota:</b> En versiones iniciales de SL esta función retornaba el tiempo transcurrido desde la medianoche.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> sec()<span class="resr"> retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<p>
    El siguiente programa muestra cómo puede usarse sec() para observar cuánto tiempo llevó la ejecución de una parte del programa. 
    En este caso, se mide cuánto tiempo llevó la ejecución repetida de una subrutina que invierte el contenido de un vector numérico.
</p>
<pre class="code">
<span class="resr">var</span>
    <span class="var">A</span> : <span class="resr">vector</span> [<span class="num">50</span>] <span class="resr">numerico</span>
    <span class="comment">/*
    * t1 significa "tiempo 1" y t2 significa "tiempo 2", es decir,
    * contienen el valor de sec() en dos momentos diferentes.
    */</span>
    <span class="var">t1</span>, <span class="var">t2</span> : <span class="resr">numerico</span>
    <span class="var">k</span> : <span class="resr">numerico</span>
<span class="resr">const</span>
    <span class="var">CANT_REP</span> = <span class="num">251</span>
<span class="resr">inicio</span>
    <span class="resr">desde</span><span class="var"> k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen(<span class="var">A</span>) {
        <span class="var">A</span> [<span class="var">k</span>] = <span class="var">k</span> * <span class="num">2</span>
    }
    <span class="var">t1</span> = sec()  
    <span class="comment">/*
    * Repetiremos CANT_REP veces lo mismo solo para que tarde un poco y
    * podamos apreciar el tiempo transcurrido; de lo contrario es muy 
    * rápido el proceso y el tiempo transcurrido es muy corto.
    */</span>
    <span class="resr">desde</span><span class="var"> k</span> = <span class="num">1</span> <span class="resr">hasta</span> <span class="var">CANT_REP</span> {
        invertir_vec(<span class="var">A</span>)
    }
    <span class="var">t2</span> = sec()
    imprimir (<span class="string">"\nEl vector A contiene:\n"</span>, <span class="var">A</span>,
             <span class="string">"\n\nEl proceso de invertir el contenido de A llevó "</span>, <span class="var">t2</span> - <span class="var">t1</span>,
             <span class="string">" segundos, repetido "</span>, <span class="var">CANT_REP</span>, <span class="string">" veces."</span>)
<span class="resr">fin</span>

<span class="resr">sub</span> invertir_vec (<span class="resr">ref</span> A : <span class="resr">vector</span> [*] <span class="resr">numerico</span>)
<span class="resr">var</span>
   <span class="var">g</span> = alen (A)
   <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   <span class="resr">desde</span><span class="var"> k</span> = <span class="num">1</span> <span class="resr">hasta</span> int(<span class="var">g</span>) / <span class="num">2</span> {
      intercambiar (A [<span class="var">k</span>], A [<span class="var">g</span> - <span class="var">k</span> + <span class="num">1</span>])
   }
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>set_color()</h3>
<p>
    Permite cambiar los colores que se usarán al imprimir mensajes en la pantalla.<br>
    El segundo parámetro de set_color() indica el color de fondo que se desea. El primer parámetro (primer_plano) indica el color del texto mismo.<br>
    Si cualquiera de los parámetros es 0, el color correspondiente no se ve afectado.<br>
    Por una decisión de diseño, los colores no tienen nombres o significados predefinidos, ya que al hacerlo se está limitando la posibilidad de portar SL a nuevas plataformas.<br>
    No tiene ningún efecto cuando el dispositivo de salida no es la pantalla.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> set_color (primer_plano, fondo : <span class="resr">numerico</span>)
</pre>

<br><hr>
<h3>set_ifs()</h3>
<p>
    Establece el separador de valores (o "campos") a ser utilizado en subsiguientes llamadas a leer().<br>
    Vea también <a href="">get_ifs()</a>.
</p>
<p class="alert">
    set_ifs() debe ser llamado luego de cada set_stdin(), pues se restaura a su valor original (",") al cambiar el archivo de entrada.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> set_ifs (c : <span class="resr">cadena</span>)
</pre>
<p>Si c contiene más de un carácter, solo se usa el primero de ellos.</p>
<h4>Ejemplo</h4>
<p>
    Supóngase que desea leerse la cédula y el nombre y apellido de una persona. Entre el nombre y el apellido hay una coma.<br>
    Como la coma es por defecto para leer() el separador de campos, si no se cambia este separador, los valores no se leerán correctamente (solo se leerá hasta el nombre y el apellido quedará en el buffer de entrada). Usando set_ifs() puede superarse esta situación.
</p>
<pre class="code">
<span class="resr">var</span>
    <span class="var">cedula</span> = <span class="string">""</span>
    <span class="var">nombre</span> = <span class="string">""</span>
<span class="resr">inicio</span>
    set_ifs (<span class="string">"+"</span>)
    imprimir (<span class="string">"\nIngrese Cédula, signo +, Nombre y apellido:"</span>)
    leer (<span class="var">cedula</span>, <span class="var">nombre</span>)
    imprimir (<span class="string">"\nCedula="</span>, <span class="var">cedula</span>, <span class="string">"\nNombre y apellido="</span>, <span class="var">nombre</span>)
<span class="resr">fin</span>   
</pre>

<br><hr>
<h3>set_curpos()</h3>
<p>
    Posiciona el cursor en la línea y columna especificadas. La esquina superior izquierda de la pantalla corresponde a la posición (1, 1), es decir, línea 1 columna 1. Si solo se desea cambiar la columna conservando la fila actual, puede pasarse 0 como columna; similar efecto se logra pasando 0 como número de línea: solo se cambia la columna.<br>
    No tiene ningún efecto cuando el dispositivo de salida no es la pantalla.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> set_color (nueva_lin, nueva_col : <span class="resr">numerico</span>)
</pre>

<br><hr>
<h3>set_ofs()</h3>
<p>
    Configura qué carácter utilizará imprimir() para separar los valores de los datos compuestos, como los registros y arreglos. Por defecto este carácter es una coma.<br>
    Además del carácter separador de valores, set_ofs() configura lo que se mostrará cuando imprimir() encuentre un arreglo que no está dimensionado. Por defecto se imprime "<nodim>".<br>
    El primer carácter del parámetro de set_ofs() es el separador y lo que sigue es el indicador de “no dimensionado”, por lo que la configuración por defecto actúa como si se hubiese hecho set_ofs(",<nodim>") al iniciar el programa.<br>
    Se usa get_ofs() para obtener estos valores vigentes.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> set_ofs (c : <span class="resr">cadena</span>)
</pre>
<h4>Ejemplo</h4>
<p>
    El siguiente ejemplo imprime los datos de cada alumno en una línea de la pantalla. Si un alumno no tiene notas, se muestra "*Sin notas". Los datos de un mismo alumno se separan unos de otros con un espacio.
</p>
<pre class="code">
<span class="resr">tipos</span>
    Alumno : <span class="resr">registro</span> {
        <span class="var">cedula</span> : <span class="resr">cadena</span>
        <span class="var">notas</span> : <span class="resr">vector</span> [*] <span class="resr">numerico</span>
    }
<span class="resr">var</span>
   <span class="var">lista</span> : <span class="resr">vector</span> [<span class="num">5</span>] Alumno
   <span class="var">k</span> = <span class="num">0</span>
<span class="resr">inicio</span>
   <span class="var">lista</span> = { {<span class="string">"1283912"</span>, {<span class="num">5</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">5</span>, <span class="num">3</span>}},
             {<span class="string">"3281242"</span>, {<span class="num">3</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">1</span>, <span class="num">4</span>}},
             {<span class="string">"1278217"</span>, {}},            <span class="comment">// Este alumno no tiene notas</span>
             {<span class="string">"2381923"</span>, {<span class="num">5</span>, <span class="num">5</span>, <span class="num">5</span>, <span class="num">5</span>, <span class="num">4</span>}},
             {<span class="string">"1938281"</span>, {<span class="num">4</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>}}
           }

   set_ofs (<span class="string">" *Sin notas"</span>)
   imprimir (<span class="string">"\nDatos de la clase:\n"</span>)
   <span class="resr">desde</span> <span class="var">k</span> = <span class="num">1</span> <span class="resr">hasta</span> alen(<span class="var">lista</span>) {
      imprimir (<span class="var">lista</span> [<span class="var">k</span>], <span class="string">"\n"</span>)
   }
<span class="resr">fin</span>   
</pre>
<p>El resultado será:</p>
<p class="alert">
    Datos de la clase:<br>
    1283912 5 4 5 5 3<br>
    3281242 3 2 3 1 4<br>
    1278217 *Sin notas<br>
    2381923 5 5 5 5 4<br>
    1938281 4 3 2 2 1
</p>

<br><hr>
<h3>set_stdin()</h3>
<p>
    Establece desde donde se obtendrán los datos cada vez que se llame a leer(). Por defecto, se lee del teclado.<br>
    Si a set_stdin() se pasa un nombre de archivo que no existe, o no se tiene permisos para leerlo, se devuelve el valor lógico FALSE.<br>
    Puede usarse “” (cadena vacía) como nombre de archivo para hacer que subsiguientes llamadas a leer() tomen los datos del teclado, cerrando así cualquier archivo que se haya abierto previamente.<br>
    set_stdin() restaura el separador de campos a “,” (coma). Debe llamar a set_ifs() luego de set_stdin() si desea usar otro separador de campos.<br>
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> set_stdin (nombre_archivo : <span class="resr">cadena</span>) <span class="resr">retorna logico</span>
</pre>
<h4>Ejemplo</h4>
<p>
    El siguiente ejemplo lee el archivo “resumen.txt” y graba en el archivo “letra_a.txt” toda línea del primer archivo que contenga la letra “a”, desplegando al final en la pantalla cuántas líneas fueron encontradas que cumplen el criterio señalado.
</p>
<pre class="code">
<span class="resr">var</span>
    <span class="var">linea</span> = <span class="string">""</span>
    <span class="var">cant_lineas</span> = <span class="num">0</span>
<span class="resr">const</span>
   <span class="var">ARCH_ENTRADA</span> = <span class="string">"resumen.txt"</span>
   <span class="var">ARCH_SALIDA</span>  = <span class="string">"letra_a.txt"</span>
<span class="resr">inicio</span>
    imprimir (<span class="string">"\nEste programa muestra cómo usar set_stdin() para leer"</span>,
             <span class="string">" desde un archivo, y set_stdout() para enviar los"</span>,
             <span class="string">" resultados a otro archivo.\n"</span>)
    <span class="resr">si</span> (<span class="resr">not</span> set_stdin (<span class="var">ARCH_ENTRADA</span>)) {
        imprimir (<span class="string">"\nNo se pudo abrir el archivo "</span>, <span class="var">ARCH_ENTRADA</span>, <span class="string">".\nEl programa no puede continuar."</span>)
        terminar(<span class="string">"\nEjecución terminada con error.\n"</span>)
   }
   <span class="comment">/*
    * Se desea leer una línea a la vez; por eso el separador es \n
    */</span>
   set_ifs (<span class="string">"\n"</span>)
   <span class="resr">si</span> (<span class="resr">not</span> set_stdout (<span class="var">ARCH_SALIDA</span>) ) {
      terminar (<span class="string">"\nNo se pudo abrir el archivo "</span> + <span class="var">ARCH_SALIDA</span>)
   }
   <span class="comment">/*
    * A partir de ahora, imprimir() grabará en el archivo abierto
    * más arriba y no mostrará nada en la pantalla.
    */</span>
   leer (<span class="var">linea</span>)
   <span class="resr">mientras</span> (<span class="resr">not</span> eof()) {
      <span class="resr">si</span> (pos (<span class="var">linea</span>, <span class="string">"a"</span>) > <span class="num">0</span>) {
         imprimir (<span class="var">linea</span>)
         inc (<span class="var">cant_lineas</span>)
      }
      leer (<span class="var">linea</span>)
   }
   <span class="comment">/*
    * Hacer que imprimir() muestre nuevamente los resultados en la pantalla.
    */</span>
   set_stdout (<span class="string">""</span>)
   imprimir (<span class="string">"\nFueron copiadas "</span>, <span class="var">cant_lineas</span>, <span class="string">" líneas\n"</span>)
<span class="resr">fin</span>   
</pre>

<br><hr>
<h3>set_stdout()</h3>
<p>
    Establece el destino de los datos que son generados a través de imprimir(). Puede ser un archivo o la pantalla, siendo este el destino por defecto.<br>
    Si a set_stdin() se pasa un nombre de archivo que no existe, éste es creado. Si el archivo ya existe, su contenido se pierde, a menos que se utilice la segunda sintaxis (ver más abajo) y se solicita que el contenido sea adicionado y no borrado.<br>
    Si el archivo no puede ser creado, porque no se tiene permisos por ejemplo, o porque ya está abierto, se retorna el valor lógico FALSE.<br>
    Puede usarse "" (cadena vacía) como nombre de archivo para hacer que subsiguientes llamadas a imprimir() envíen los datos a la pantalla, cerrando así cualquier archivo que se haya abierto previamente.
</p>
<h4>Sintaxis</h4>
<p>
    <u>Alternativa 1</u>: El archivo se crea si no existe. Si ya existe, los datos previos se pierden.
</p>
<pre class="code">
<span class="resr">sub</span> set_stdout(nombre_archivo : <span class="resr">cadena</span>) <span class="resr">retorna logico</span>
</pre>
<p>
    <u>Alternativa 2</u>: Se especifica el "modo" en que se abrirá el archivo.
</p>
<pre class="code">
<span class="resr">sub</span> set_stdout(nombre_archivo : <span class="resr">cadena</span>; modo_apertura : <span class="resr">cadena</span>) <span class="resr">retorna logico</span>
</pre>
<p>
     Los valores posibles del parámetro "modo_apertura" son:<br>
     "wt" : El contenido previo del archivo se pierde. Si el archivo no existe, se crea. Equivale a no pasar este segundo parámetro.<br>
     "at" : Todo lo que se imprima se agregará al archivo, conservando su contenido previo. Si el archivo no existe, se crea.
</p>
<h4>Ejemplo</h4>
<p>Vea el ejemplo de <a href="">set_stdin()</a>.</p>

<br><hr>
<h3>sin()</h3>
<p>Calcula el seno de un ángulo expresado en radianes.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> sin (a : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>sqrt()</h3>
<p> Calcula la raíz cuadrada de un número.El número cuya raíz cuadrada se desea calcular debe ser positivo. En caso contrario, se producirá un error de ejecución y el programa terminará.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> sqrt (n : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>strdup()</h3>
<p>Dada una cadena y un número n, produce una nueva cadena que consta de n copias de la cadena original.</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> strdup (c : <span class="resr">cadena</span>; n : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<h4>Ejemplo</h4>
<p>El siguiente programa imprimirá 30 veces "[]".</p>
<pre class="code">
<span class="resr">inicio</span>
   imprimir (<span class="string">"\n"</span>, strdup (<span class="string">"[]"</span>, <span class="num">30</span>))
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>strlen()</h3>
<p>
    Retorna la cantidad de caracteres de que consta una cadena.<br>
    La cadena vacía ("") tiene longitud 0.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> strlen (c : <span class="resr">cadena</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
   <span class="var">m</span> = <span class="string">"casa"</span>
<span class="resr">inicio</span>
   imprimir (<span class="string">"\nLa palabra "</span>, <span class="var">m</span>, <span class="string">" tiene "</span>, strlen (<span class="var">m</span>), <span class="string">" letras"</span>))
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>substr()</h3>
<p>
    Hace una copia de una porción de una cadena, iniciando en cierta posición de carácter.<br>
    Si se omite el tercer parámetro, que indica cantidad de caracteres a copiar, se tomarán todos los caracteres de la cadena partiendo de la posición indicada por el segundo parámetro.<br>
    Si la posición inicial de copia es mayor a la longitud de la cadena, se retorna una cadena vacía.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> substr (c : <span class="resr">cadena</span>; pos_inicial : <span class="resr">numerico</span>; cant : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
   <span class="var">z</span> = <span class="string">"ABCD"</span>
<span class="resr">inicio</span>
    imprimir (<span class="string">"\nEl segundo carácter es "</span>, substr (<span class="var">z</span>, <span class="num">2</span>, <span class="num">1</span>))
    imprimir (<span class="string">"\nLos últimos tres son "</span>, substr (<span class="var">z</span>, <span class="num">2</span>))
    imprimir (<span class="string">"\nDesde la posición 5 solo hay vacío:"</span>, substr (<span class="var">z</span>, <span class="num">5</span>, <span class="num">5</span>))
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>swap()</h3>
<p>
    Vea <a href="">intercambiar()</a>.
</p>

<br><hr>
<h3>tan()</h3>
<p>
    Calcula la tangente de un ángulo, expresado en radianes.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> tan (a : <span class="resr">numerico</span>) <span class="resr">retorna numerico</span>
</pre>

<br><hr>
<h3>terminar()</h3>
<p>
    Hace que el programa termine anticipadamente su ejecución.Note que el control NUNCA retorna al programa.<br>
    Puede proveerse un mensaje que se imprimirá antes de que termine la ejecución. Este parámetro es opcional; si no se especifica nada, se asume "".
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> terminar (mensaje : <span class="resr">cadena</span>)
</pre>
<h4>Ejemplo</h4>
<p>Vea el ejemplo dado para <a href="">set_stdin()</a>.</p>

<br><hr>
<h3>upper()</h3>
<p>
     Dada una cadena como parámetro, retorna una nueva cadena que consta de los mismos caracteres del parámetro, pero con aquellos que sean alfabéticos convertidos a mayúsculas.<br>
     Vea también <a href="">lower()</a>.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> upper (c : <span class="resr">cadena</span>) <span class="resr">retorna cadena</span>
</pre>

<br><hr>
<h3>val()</h3>
<p>
    Dado un valor de cadena que contiene dígitos de un número entero o decimal, produce un valor numérico que es almacenable en una variable de tal tipo, o que puede combinarse en expresiones numéricas.
</p>
<p class="alert">
A menudo se escucha decir que val() "convierte" una cadena a numérico. Esto es técnicamente incorrecto, pero forma parte de la expresión cotidiana en programación. Es incorrecto porque el valor original permanece intacto. 
</p>
<p>
    Si la cadena que se pasa como parámetro no contiene una secuencia que expresa un número, se retorna 0.
    Vea también <a href="">str()</a>.
</p>
<h4>Sintaxis</h4>
<pre class="code">
<span class="resr">sub</span> val (c : <span class="resr">cadena</span>) <span class="resr">retorna numerico</span>
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
    <span class="var">z</span> = <span class="string">"123.4"</span>
<span class="resr">inicio</span>
    imprimir (<span class="string">"\n"</span>, <span class="var">z</span>, <span class="string">" + 1 es "</span>, val (<span class="var">z</span>) + <span class="num">1</span>)
    imprimir (<span class="string">"\n-12 * 2 es "</span>, val (<span class="string">"-12"</span>) * <span class="num">2</span>)
    imprimir (<span class="string">"\n'abc'+ 1 es "</span>, val (<span class="string">"abc"</span>) + <span class="num">1</span>)
<span class="resr">fin</span>
</pre>

<br><hr>
<h3>str()</h3>
<p>
    Dado un valor numérico, produce la representación de ese mismo valor pero en formato de cadena. Varios aspectos de formateo pueden ser controlados por parámetros opcionales. Por ejemplo, la conversión puede tomar solo la parte entera, o incluir cierta cantidad de decimales, etc.<br>
    Se lo utiliza generalmente para mostrar un valor numérico con una cantidad precisa de dígitos decimales, más allá de lo que imprimir() muestra por defecto.
</p>
<p class="alert">
A menudo se escucha decir que str() "convierte" un valor numérico en cadena. Esto es técnicamente incorrecto, pero forma parte de la expresión cotidiana en programación. Es incorrecto porque el valor original permanece intacto. Lo que en realidad hace str() es producir una representación textual formateada del número.
</p>
<p>
    La función str() siempre redondea (por exceso) el valor numérico. Esto quiere decir que si se tiene una variable numérica con valor 78.135, al formatearlo con str() a dos decimales, se tendrá una cadena donde los últimos dos dígitos decimales serán "14".<br>
    Vea también <a href="">val()</a>.
</p>
<h4>Sintaxis</h4>
<p><u>Alternativa 1</u>: Formateo por defecto: 2 decimales, ancho total no especificado y alineación a la izquierda.</p>
<pre class="code">
<span class="resr">sub</span> str (n : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<p><u>Alternativa 2</u>: Formateo con 2 decimales pero con un ancho total determinado. En el ancho se debe contar el punto decimal, es decir, un ancho de 6 alanza para 3 dígitos enteros, un punto decimal y dos dígitos decimales. La alineación es a la derecha.</p>
<pre class="code">
<span class="resr">sub</span> str (n : <span class="resr">numerico</span>; ancho : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<p>Si la cantidad de dígitos de n es superior a ancho, se ignora el ancho y se retorna el resultado como si ancho haya sido 0.Este comportamiento se mantiene para todas las alternativas que acepten el parámetro ancho.</p>
<p><u>Alternativa 3</u>: Formateo con un ancho determinado, pero indicando una cantidad específica de dígitos decimales. La alineación es a la derecha.</p>
<pre class="code">
<span class="resr">sub</span> str (n : <span class="resr">numerico</span>; ancho : <span class="resr">numerico</span>; cant_dec : <span class="resr">numerico</span>) <span class="resr">retorna cadena</span>
</pre>
<p><u>Alternativa 4</u>: Además de formatear con un ancho total definido y cantidad de decimales, se rellenará a la izquierda el resultado con cierto carácter, si el número formateado tiene menos dígitos que el ancho especificado.</p>
<pre class="code">
<span class="resr">sub</span> str (n, cant_dec : <span class="resr">numerico</span>; relleno : <span class="resr">cadena</span>) <span class="resr">retorna cadena</span>
</pre>
<h4>Ejemplo</h4>
<pre class="code">
<span class="resr">var</span>
    <span class="var">n</span> = <span class="num">123.40451</span>
    <span class="var">s</span> = <span class="string">""</span>
<span class="resr">inicio</span>
    <span class="var">s</span> = str (<span class="var">n</span>);             imprimir (<span class="string">"\nAlternativa 1:"</span>,  <span class="var">s</span>)
    <span class="var">s</span> = str (<span class="var">n</span>, <span class="num">10</span>);         imprimir (<span class="string">"\nAlternativa 2:"</span>,  <span class="var">s</span>)
    <span class="var">s</span> = str (<span class="var">n</span>, <span class="num">10</span>, <span class="num">3</span>);      imprimir (<span class="string">"\nAlternativa 3:"</span>,  <span class="var">s</span>)
    <span class="var">s</span> = str (<span class="var">n</span>, <span class="num">0</span>, <span class="num">0</span>);       imprimir (<span class="string">"\nAlternativa 3b:"</span>, <span class="var">s</span>)
    <span class="var">s</span> = str (<span class="var">n</span>, <span class="num">10</span>, <span class="num">0</span>, <span class="string">"*"</span>); imprimir (<span class="string">"\nAlternativa 4:"</span>,  <span class="var">s</span>)
    <span class="var">s</span> = str (<span class="var">n</span>, <span class="num">1</span>, <span class="num">1</span>);       imprimir (<span class="string">"\nAlternativa 3c:"</span>, <span class="var">s</span>)
<span class="resr">fin</span>
</pre>
</body>
</html>
